// SPDX-License-Identifier: MIT
// Copyright (c) 2023, Oleksandr Koval

// This file was generated by sbeppc 1.3.0
#pragma once

#include <sbepp/sbepp.hpp>

SBEPP_WARNINGS_OFF();

#include "../schema/schema.hpp"
#include "../types/messageHeader.hpp"
#include "../types/FramingHeader.hpp"
#include "../types/PacketHeader.hpp"


namespace bovespa_mbo_sbe
{
namespace detail
{
namespace messages
{



template<typename Byte>
class message_30 : public ::sbepp::detail::message_base<
    Byte, ::bovespa_mbo_sbe::types::messageHeader<Byte>>
{
public:
    using ::sbepp::detail::message_base<
        Byte, ::bovespa_mbo_sbe::types::messageHeader<Byte>>::message_base;
    using ::sbepp::detail::message_base<
        Byte, ::bovespa_mbo_sbe::types::messageHeader<Byte>>::operator();

    constexpr ::bovespa_mbo_sbe::types::PacketHeader<Byte> packetHeader() const noexcept
    {
        return ::sbepp::detail::get_static_field_view<::bovespa_mbo_sbe::types::PacketHeader<Byte>>(
            *this, 8);
    }
    constexpr ::bovespa_mbo_sbe::types::FramingHeader<Byte> framingHeader() const noexcept
    {
        return ::sbepp::detail::get_static_field_view<::bovespa_mbo_sbe::types::FramingHeader<Byte>>(
            *this, 24);
    }

    template<
        typename Cursor,
        typename = ::sbepp::detail::enable_if_cursor_compatible_t<
            Byte, ::sbepp::detail::cursor_byte_type_t<Cursor>>>
    SBEPP_CPP20_CONSTEXPR auto packetHeader(Cursor&& c) const noexcept
        -> ::sbepp::detail::cursor_result_type_t<Cursor, 
            ::bovespa_mbo_sbe::types::PacketHeader<::sbepp::detail::cursor_byte_type_t<Cursor>>>
    {
        return c.template get_static_field_view<::bovespa_mbo_sbe::types::PacketHeader<::sbepp::detail::cursor_byte_type_t<Cursor>>>(
            *this, 0, 8);
    }

    template<
        typename Cursor,
        typename = ::sbepp::detail::enable_if_cursor_compatible_t<
            Byte, ::sbepp::detail::cursor_byte_type_t<Cursor>>>
    SBEPP_CPP20_CONSTEXPR auto framingHeader(Cursor&& c) const noexcept
        -> ::sbepp::detail::cursor_result_type_t<Cursor,
            ::bovespa_mbo_sbe::types::FramingHeader<::sbepp::detail::cursor_byte_type_t<Cursor>>>
    {
        return c.template get_last_static_field_view<::bovespa_mbo_sbe::types::FramingHeader<
            ::sbepp::detail::cursor_byte_type_t<Cursor>>>(
                *this, 0, 24);
    }


    template<
        typename T = void,
        typename = ::sbepp::detail::enable_if_writable_t<Byte, T>>
    SBEPP_CPP14_CONSTEXPR ::bovespa_mbo_sbe::types::messageHeader<Byte>
        operator()(::sbepp::detail::fill_message_header_tag) const noexcept
    {
        auto header = operator()(::sbepp::detail::get_header_tag{});
        header.schemaId({2});
        header.templateId({0});
        header.version({8});
        header.blockLength({20});
        
        
        return header;
    }


    SBEPP_CPP20_CONSTEXPR std::size_t operator()(
        ::sbepp::detail::size_bytes_tag) const noexcept
    {
        return 8 + (*this)(::sbepp::detail::get_block_length_tag{});
    }


    template<typename Visitor, typename Cursor>
    SBEPP_CPP14_CONSTEXPR void operator()(
        ::sbepp::detail::visit_tag, Visitor& v, Cursor& c)
    {
        v.template on_message(*this, c, ::bovespa_mbo_sbe::schema::messages::HeaderMessage_0{});
    }


    template<typename Visitor, typename Cursor>
    constexpr bool operator()(
        ::sbepp::detail::visit_children_tag, Visitor& v, Cursor& c) const
    {
        return v.template on_field(this->packetHeader(c), ::bovespa_mbo_sbe::schema::messages::HeaderMessage_0::packetHeader{})
||v.template on_field(this->framingHeader(c), ::bovespa_mbo_sbe::schema::messages::HeaderMessage_0::framingHeader{});
    }

};

} // namespace messages
} // namespace detail

namespace messages
{

    template<typename Byte>
    using HeaderMessage_0 = ::bovespa_mbo_sbe::detail::messages::message_30<Byte>;

} // namespace messages
} // namespace bovespa_mbo_sbe

namespace sbepp
{

template<>
class field_traits<::bovespa_mbo_sbe::schema::messages::HeaderMessage_0::packetHeader>
{
public:
    static constexpr const char* name() noexcept
    {
        return "packetHeader";
    }

    static constexpr member_id_t id() noexcept
    {
        return 2;
    }

    static constexpr const char* description() noexcept
    {
        return "";
    }

    static constexpr field_presence presence() noexcept
    {
        return ::sbepp::field_presence::required;
    }
    
    static constexpr offset_t offset() noexcept
    {
        return {0};
    }


    static constexpr version_t since_version() noexcept
    {
        return 0;
    }

    
    
    template<typename Byte>
    using value_type = ::bovespa_mbo_sbe::types::PacketHeader<Byte>;

    using value_type_tag = ::bovespa_mbo_sbe::schema::types::PacketHeader;
};

template<>
class field_traits<::bovespa_mbo_sbe::schema::messages::HeaderMessage_0::framingHeader>
{
public:
    static constexpr const char* name() noexcept
    {
        return "framingHeader";
    }

    static constexpr member_id_t id() noexcept
    {
        return 3;
    }

    static constexpr const char* description() noexcept
    {
        return "";
    }

    static constexpr field_presence presence() noexcept
    {
        return ::sbepp::field_presence::required;
    }
    
    static constexpr offset_t offset() noexcept
    {
        return {16};
    }


    static constexpr version_t since_version() noexcept
    {
        return 0;
    }

    
    
    template<typename Byte>
    using value_type = ::bovespa_mbo_sbe::types::FramingHeader<Byte>;

    using value_type_tag = ::bovespa_mbo_sbe::schema::types::FramingHeader;
};

template<>
class message_traits<::bovespa_mbo_sbe::schema::messages::HeaderMessage_0>
{
public:
    static constexpr const char* name() noexcept
    {
        return "HeaderMessage_0";
    }

    static constexpr const char* description() noexcept
    {
        return "Generate code for PacketHeader and FramingHeader for convenience, making easier to handle those headers as SBE instead of handling as pure binary format. It is not meant to be used as a standalone SBE message.";
    }

    static constexpr message_id_t id() noexcept
    {
        return 0;
    }

    static constexpr block_length_t block_length() noexcept
    {
        return 20;
    }

    static constexpr const char* semantic_type() noexcept
    {
        return "";
    }

    static constexpr version_t since_version() noexcept
    {
        return 0;
    }

    
    
    template<typename Byte>
    using value_type = ::bovespa_mbo_sbe::messages::HeaderMessage_0<Byte>;

    using schema_tag = ::bovespa_mbo_sbe::schema;
    static constexpr ::std::size_t size_bytes() noexcept
    {
        return ::sbepp::composite_traits<
            ::sbepp::schema_traits<schema_tag>::header_type_tag>::size_bytes()
            + block_length();
    }

};

template<typename Byte>
struct traits_tag<::bovespa_mbo_sbe::messages::HeaderMessage_0<Byte>>
{
    using type = ::bovespa_mbo_sbe::schema::messages::HeaderMessage_0;
};


}  // namespace sbepp

SBEPP_WARNINGS_ON();
